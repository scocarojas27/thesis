{"ast":null,"code":"'use strict';\n\nvar Class = require('../util/class'),\n    Promise = require('../util/promise'),\n    Set = require('../util/set'),\n    URI = require('../util/uri'),\n    browser = require('../util/browser'),\n    copyObject = require('../util/copy_object'),\n    assign = require('../util/assign'),\n    toJSON = require('../util/to_json'),\n    ws = require('../util/websocket'),\n    Deferrable = require('../mixins/deferrable'),\n    Transport = require('./transport');\n\nvar WebSocket = assign(Class(Transport, {\n  UNCONNECTED: 1,\n  CONNECTING: 2,\n  CONNECTED: 3,\n  batching: false,\n  isUsable: function (callback, context) {\n    this.callback(function () {\n      callback.call(context, true);\n    });\n    this.errback(function () {\n      callback.call(context, false);\n    });\n    this.connect();\n  },\n  request: function (messages) {\n    this._pending = this._pending || new Set();\n\n    for (var i = 0, n = messages.length; i < n; i++) this._pending.add(messages[i]);\n\n    var self = this;\n    var promise = new Promise(function (resolve, reject) {\n      self.callback(function (socket) {\n        if (!socket || socket.readyState !== 1) return;\n        socket.send(toJSON(messages));\n        resolve(socket);\n      });\n      self.connect();\n    });\n    return {\n      abort: function () {\n        promise.then(function (ws) {\n          ws.close();\n        });\n      }\n    };\n  },\n  connect: function () {\n    if (WebSocket._unloaded) return;\n    this._state = this._state || this.UNCONNECTED;\n    if (this._state !== this.UNCONNECTED) return;\n    this._state = this.CONNECTING;\n\n    var socket = this._createSocket();\n\n    if (!socket) return this.setDeferredStatus('failed');\n    var self = this;\n\n    socket.onopen = function () {\n      if (socket.headers) self._storeCookies(socket.headers['set-cookie']);\n      self._socket = socket;\n      self._state = self.CONNECTED;\n      self._everConnected = true;\n      self.setDeferredStatus('succeeded', socket);\n    };\n\n    var closed = false;\n\n    socket.onclose = socket.onerror = function () {\n      if (closed) return;\n      closed = true;\n      var wasConnected = self._state === self.CONNECTED;\n      socket.onopen = socket.onclose = socket.onerror = socket.onmessage = null;\n      delete self._socket;\n      self._state = self.UNCONNECTED;\n      var pending = self._pending ? self._pending.toArray() : [];\n      delete self._pending;\n\n      if (wasConnected || self._everConnected) {\n        self.setDeferredStatus('unknown');\n\n        self._handleError(pending, wasConnected);\n      } else {\n        self.setDeferredStatus('failed');\n      }\n    };\n\n    socket.onmessage = function (event) {\n      var replies;\n\n      try {\n        replies = JSON.parse(event.data);\n      } catch (error) {}\n\n      if (!replies) return;\n      replies = [].concat(replies);\n\n      for (var i = 0, n = replies.length; i < n; i++) {\n        if (replies[i].successful === undefined) continue;\n\n        self._pending.remove(replies[i]);\n      }\n\n      self._receive(replies);\n    };\n  },\n  close: function () {\n    if (!this._socket) return;\n\n    this._socket.close();\n  },\n  _createSocket: function () {\n    var url = WebSocket.getSocketUrl(this.endpoint),\n        headers = this._dispatcher.headers,\n        extensions = this._dispatcher.wsExtensions,\n        cookie = this._getCookies(),\n        tls = this._dispatcher.tls,\n        options = {\n      extensions: extensions,\n      headers: headers,\n      proxy: this._proxy,\n      tls: tls\n    };\n\n    if (cookie !== '') options.headers['Cookie'] = cookie;\n\n    try {\n      return ws.create(url, [], options);\n    } catch (e) {// catch CSP error to allow transport to fallback to next connType\n    }\n  }\n}), {\n  PROTOCOLS: {\n    'http:': 'ws:',\n    'https:': 'wss:'\n  },\n  create: function (dispatcher, endpoint) {\n    var sockets = dispatcher.transports.websocket = dispatcher.transports.websocket || {};\n    sockets[endpoint.href] = sockets[endpoint.href] || new this(dispatcher, endpoint);\n    return sockets[endpoint.href];\n  },\n  getSocketUrl: function (endpoint) {\n    endpoint = copyObject(endpoint);\n    endpoint.protocol = this.PROTOCOLS[endpoint.protocol];\n    return URI.stringify(endpoint);\n  },\n  isUsable: function (dispatcher, endpoint, callback, context) {\n    this.create(dispatcher, endpoint).isUsable(callback, context);\n  }\n});\nassign(WebSocket.prototype, Deferrable);\n\nif (browser.Event && global.onbeforeunload !== undefined) {\n  browser.Event.on(global, 'beforeunload', function () {\n    if (WebSocket._unloaded === undefined) WebSocket._unloaded = true;\n  });\n}\n\nmodule.exports = WebSocket;","map":{"version":3,"sources":["/home/scocarojas/Documents/prototype/node_modules/faye/src/transport/web_socket.js"],"names":["Class","require","Promise","Set","URI","browser","copyObject","assign","toJSON","ws","Deferrable","Transport","WebSocket","UNCONNECTED","CONNECTING","CONNECTED","batching","isUsable","callback","context","call","errback","connect","request","messages","_pending","i","n","length","add","self","promise","resolve","reject","socket","readyState","send","abort","then","close","_unloaded","_state","_createSocket","setDeferredStatus","onopen","headers","_storeCookies","_socket","_everConnected","closed","onclose","onerror","wasConnected","onmessage","pending","toArray","_handleError","event","replies","JSON","parse","data","error","concat","successful","undefined","remove","_receive","url","getSocketUrl","endpoint","_dispatcher","extensions","wsExtensions","cookie","_getCookies","tls","options","proxy","_proxy","create","e","PROTOCOLS","dispatcher","sockets","transports","websocket","href","protocol","stringify","prototype","Event","global","onbeforeunload","on","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Class      = require('../util/class'),\n    Promise    = require('../util/promise'),\n    Set        = require('../util/set'),\n    URI        = require('../util/uri'),\n    browser    = require('../util/browser'),\n    copyObject = require('../util/copy_object'),\n    assign     = require('../util/assign'),\n    toJSON     = require('../util/to_json'),\n    ws         = require('../util/websocket'),\n    Deferrable = require('../mixins/deferrable'),\n    Transport  = require('./transport');\n\nvar WebSocket = assign(Class(Transport, {\n  UNCONNECTED:  1,\n  CONNECTING:   2,\n  CONNECTED:    3,\n\n  batching:     false,\n\n  isUsable: function(callback, context) {\n    this.callback(function() { callback.call(context, true) });\n    this.errback(function() { callback.call(context, false) });\n    this.connect();\n  },\n\n  request: function(messages) {\n    this._pending = this._pending || new Set();\n    for (var i = 0, n = messages.length; i < n; i++) this._pending.add(messages[i]);\n\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n      self.callback(function(socket) {\n        if (!socket || socket.readyState !== 1) return;\n        socket.send(toJSON(messages));\n        resolve(socket);\n      });\n\n      self.connect();\n    });\n\n    return {\n      abort: function() { promise.then(function(ws) { ws.close() }) }\n    };\n  },\n\n  connect: function() {\n    if (WebSocket._unloaded) return;\n\n    this._state = this._state || this.UNCONNECTED;\n    if (this._state !== this.UNCONNECTED) return;\n    this._state = this.CONNECTING;\n\n    var socket = this._createSocket();\n    if (!socket) return this.setDeferredStatus('failed');\n\n    var self = this;\n\n    socket.onopen = function() {\n      if (socket.headers) self._storeCookies(socket.headers['set-cookie']);\n      self._socket = socket;\n      self._state = self.CONNECTED;\n      self._everConnected = true;\n      self.setDeferredStatus('succeeded', socket);\n    };\n\n    var closed = false;\n    socket.onclose = socket.onerror = function() {\n      if (closed) return;\n      closed = true;\n\n      var wasConnected = (self._state === self.CONNECTED);\n      socket.onopen = socket.onclose = socket.onerror = socket.onmessage = null;\n\n      delete self._socket;\n      self._state = self.UNCONNECTED;\n\n      var pending = self._pending ? self._pending.toArray() : [];\n      delete self._pending;\n\n      if (wasConnected || self._everConnected) {\n        self.setDeferredStatus('unknown');\n        self._handleError(pending, wasConnected);\n      } else {\n        self.setDeferredStatus('failed');\n      }\n    };\n\n    socket.onmessage = function(event) {\n      var replies;\n      try { replies = JSON.parse(event.data) } catch (error) {}\n\n      if (!replies) return;\n\n      replies = [].concat(replies);\n\n      for (var i = 0, n = replies.length; i < n; i++) {\n        if (replies[i].successful === undefined) continue;\n        self._pending.remove(replies[i]);\n      }\n      self._receive(replies);\n    };\n  },\n\n  close: function() {\n    if (!this._socket) return;\n    this._socket.close();\n  },\n\n  _createSocket: function() {\n    var url        = WebSocket.getSocketUrl(this.endpoint),\n        headers    = this._dispatcher.headers,\n        extensions = this._dispatcher.wsExtensions,\n        cookie     = this._getCookies(),\n        tls        = this._dispatcher.tls,\n        options    = { extensions: extensions, headers: headers, proxy: this._proxy, tls: tls };\n\n    if (cookie !== '') options.headers['Cookie'] = cookie;\n\n    try {\n      return ws.create(url, [], options);\n    } catch (e) {\n      // catch CSP error to allow transport to fallback to next connType\n    }\n  }\n\n}), {\n  PROTOCOLS: {\n    'http:':  'ws:',\n    'https:': 'wss:'\n  },\n\n  create: function(dispatcher, endpoint) {\n    var sockets = dispatcher.transports.websocket = dispatcher.transports.websocket || {};\n    sockets[endpoint.href] = sockets[endpoint.href] || new this(dispatcher, endpoint);\n    return sockets[endpoint.href];\n  },\n\n  getSocketUrl: function(endpoint) {\n    endpoint = copyObject(endpoint);\n    endpoint.protocol = this.PROTOCOLS[endpoint.protocol];\n    return URI.stringify(endpoint);\n  },\n\n  isUsable: function(dispatcher, endpoint, callback, context) {\n    this.create(dispatcher, endpoint).isUsable(callback, context);\n  }\n});\n\nassign(WebSocket.prototype, Deferrable);\n\nif (browser.Event && global.onbeforeunload !== undefined) {\n  browser.Event.on(global, 'beforeunload', function() {\n    if (WebSocket._unloaded === undefined)\n      WebSocket._unloaded = true;\n  });\n}\n\nmodule.exports = WebSocket;\n"]},"metadata":{},"sourceType":"script"}