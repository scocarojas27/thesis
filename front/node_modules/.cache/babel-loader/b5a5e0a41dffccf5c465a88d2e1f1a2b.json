{"ast":null,"code":"'use strict';\n\nvar Class = require('../util/class'),\n    Cookie = require('../util/cookies').Cookie,\n    Promise = require('../util/promise'),\n    array = require('../util/array'),\n    assign = require('../util/assign'),\n    Logging = require('../mixins/logging'),\n    Timeouts = require('../mixins/timeouts'),\n    Channel = require('../protocol/channel');\n\nvar Transport = assign(Class({\n  className: 'Transport',\n  DEFAULT_PORTS: {\n    'http:': 80,\n    'https:': 443,\n    'ws:': 80,\n    'wss:': 443\n  },\n  MAX_DELAY: 0,\n  batching: true,\n  initialize: function (dispatcher, endpoint) {\n    this._dispatcher = dispatcher;\n    this.endpoint = endpoint;\n    this._outbox = [];\n    this._proxy = assign({}, this._dispatcher.proxy);\n    if (!this._proxy.origin) this._proxy.origin = this._findProxy();\n  },\n  close: function () {},\n  encode: function (messages) {\n    return '';\n  },\n  sendMessage: function (message) {\n    this.debug('Client ? sending message to ?: ?', this._dispatcher.clientId, this.endpoint.href, message);\n    if (!this.batching) return Promise.resolve(this.request([message]));\n\n    this._outbox.push(message);\n\n    this._flushLargeBatch();\n\n    if (message.channel === Channel.HANDSHAKE) return this._publish(0.01);\n    if (message.channel === Channel.CONNECT) this._connectMessage = message;\n    return this._publish(this.MAX_DELAY);\n  },\n  _makePromise: function () {\n    var self = this;\n    this._requestPromise = this._requestPromise || new Promise(function (resolve) {\n      self._resolvePromise = resolve;\n    });\n  },\n  _publish: function (delay) {\n    this._makePromise();\n\n    this.addTimeout('publish', delay, function () {\n      this._flush();\n\n      delete this._requestPromise;\n    }, this);\n    return this._requestPromise;\n  },\n  _flush: function () {\n    this.removeTimeout('publish');\n    if (this._outbox.length > 1 && this._connectMessage) this._connectMessage.advice = {\n      timeout: 0\n    };\n\n    this._resolvePromise(this.request(this._outbox));\n\n    this._connectMessage = null;\n    this._outbox = [];\n  },\n  _flushLargeBatch: function () {\n    var string = this.encode(this._outbox);\n    if (string.length < this._dispatcher.maxRequestSize) return;\n\n    var last = this._outbox.pop();\n\n    this._makePromise();\n\n    this._flush();\n\n    if (last) this._outbox.push(last);\n  },\n  _receive: function (replies) {\n    if (!replies) return;\n    replies = [].concat(replies);\n    this.debug('Client ? received from ? via ?: ?', this._dispatcher.clientId, this.endpoint.href, this.connectionType, replies);\n\n    for (var i = 0, n = replies.length; i < n; i++) this._dispatcher.handleResponse(replies[i]);\n  },\n  _handleError: function (messages, immediate) {\n    messages = [].concat(messages);\n    this.debug('Client ? failed to send to ? via ?: ?', this._dispatcher.clientId, this.endpoint.href, this.connectionType, messages);\n\n    for (var i = 0, n = messages.length; i < n; i++) this._dispatcher.handleError(messages[i]);\n  },\n  _getCookies: function () {\n    var cookies = this._dispatcher.cookies,\n        url = this.endpoint.href;\n    if (!cookies) return '';\n    return array.map(cookies.getCookiesSync(url), function (cookie) {\n      return cookie.cookieString();\n    }).join('; ');\n  },\n  _storeCookies: function (setCookie) {\n    var cookies = this._dispatcher.cookies,\n        url = this.endpoint.href,\n        cookie;\n    if (!setCookie || !cookies) return;\n    setCookie = [].concat(setCookie);\n\n    for (var i = 0, n = setCookie.length; i < n; i++) {\n      cookie = Cookie.parse(setCookie[i]);\n      cookies.setCookieSync(cookie, url);\n    }\n  },\n  _findProxy: function () {\n    if (typeof process === 'undefined') return undefined;\n    var protocol = this.endpoint.protocol;\n    if (!protocol) return undefined;\n    var name = protocol.replace(/:$/, '').toLowerCase() + '_proxy',\n        upcase = name.toUpperCase(),\n        env = process.env,\n        keys,\n        proxy;\n\n    if (name === 'http_proxy' && env.REQUEST_METHOD) {\n      keys = Object.keys(env).filter(function (k) {\n        return /^http_proxy$/i.test(k);\n      });\n\n      if (keys.length === 1) {\n        if (keys[0] === name && env[upcase] === undefined) proxy = env[name];\n      } else if (keys.length > 1) {\n        proxy = env[name];\n      }\n\n      proxy = proxy || env['CGI_' + upcase];\n    } else {\n      proxy = env[name] || env[upcase];\n      if (proxy && !env[name]) console.warn('The environment variable ' + upcase + ' is discouraged. Use ' + name + '.');\n    }\n\n    return proxy;\n  }\n}), {\n  get: function (dispatcher, allowed, disabled, callback, context) {\n    var endpoint = dispatcher.endpoint;\n    array.asyncEach(this._transports, function (pair, resume) {\n      var connType = pair[0],\n          klass = pair[1],\n          connEndpoint = dispatcher.endpointFor(connType);\n      if (array.indexOf(disabled, connType) >= 0) return resume();\n\n      if (array.indexOf(allowed, connType) < 0) {\n        klass.isUsable(dispatcher, connEndpoint, function () {});\n        return resume();\n      }\n\n      klass.isUsable(dispatcher, connEndpoint, function (isUsable) {\n        if (!isUsable) return resume();\n        var transport = klass.hasOwnProperty('create') ? klass.create(dispatcher, connEndpoint) : new klass(dispatcher, connEndpoint);\n        callback.call(context, transport);\n      });\n    }, function () {\n      throw new Error('Could not find a usable connection type for ' + endpoint.href);\n    });\n  },\n  register: function (type, klass) {\n    this._transports.push([type, klass]);\n\n    klass.prototype.connectionType = type;\n  },\n  getConnectionTypes: function () {\n    return array.map(this._transports, function (t) {\n      return t[0];\n    });\n  },\n  disable: function (feature) {\n    if (feature !== 'autodisconnect') return;\n\n    for (var i = 0; i < this._transports.length; i++) this._transports[i][1]._unloaded = false;\n  },\n  _transports: []\n});\nassign(Transport.prototype, Logging);\nassign(Transport.prototype, Timeouts);\nmodule.exports = Transport;","map":{"version":3,"sources":["/home/scocarojas/Documents/prototype/front/node_modules/faye/src/transport/transport.js"],"names":["Class","require","Cookie","Promise","array","assign","Logging","Timeouts","Channel","Transport","className","DEFAULT_PORTS","MAX_DELAY","batching","initialize","dispatcher","endpoint","_dispatcher","_outbox","_proxy","proxy","origin","_findProxy","close","encode","messages","sendMessage","message","debug","clientId","href","resolve","request","push","_flushLargeBatch","channel","HANDSHAKE","_publish","CONNECT","_connectMessage","_makePromise","self","_requestPromise","_resolvePromise","delay","addTimeout","_flush","removeTimeout","length","advice","timeout","string","maxRequestSize","last","pop","_receive","replies","concat","connectionType","i","n","handleResponse","_handleError","immediate","handleError","_getCookies","cookies","url","map","getCookiesSync","cookie","cookieString","join","_storeCookies","setCookie","parse","setCookieSync","process","undefined","protocol","name","replace","toLowerCase","upcase","toUpperCase","env","keys","REQUEST_METHOD","Object","filter","k","test","console","warn","get","allowed","disabled","callback","context","asyncEach","_transports","pair","resume","connType","klass","connEndpoint","endpointFor","indexOf","isUsable","transport","hasOwnProperty","create","call","Error","register","type","prototype","getConnectionTypes","t","disable","feature","_unloaded","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Class    = require('../util/class'),\n    Cookie   = require('../util/cookies').Cookie,\n    Promise  = require('../util/promise'),\n    array    = require('../util/array'),\n    assign   = require('../util/assign'),\n    Logging  = require('../mixins/logging'),\n    Timeouts = require('../mixins/timeouts'),\n    Channel  = require('../protocol/channel');\n\nvar Transport = assign(Class({ className: 'Transport',\n  DEFAULT_PORTS: { 'http:': 80, 'https:': 443, 'ws:': 80, 'wss:': 443 },\n  MAX_DELAY:     0,\n\n  batching:  true,\n\n  initialize: function(dispatcher, endpoint) {\n    this._dispatcher = dispatcher;\n    this.endpoint    = endpoint;\n    this._outbox     = [];\n    this._proxy      = assign({}, this._dispatcher.proxy);\n\n    if (!this._proxy.origin)\n      this._proxy.origin = this._findProxy();\n  },\n\n  close: function() {},\n\n  encode: function(messages) {\n    return '';\n  },\n\n  sendMessage: function(message) {\n    this.debug('Client ? sending message to ?: ?',\n               this._dispatcher.clientId, this.endpoint.href, message);\n\n    if (!this.batching) return Promise.resolve(this.request([message]));\n\n    this._outbox.push(message);\n    this._flushLargeBatch();\n\n    if (message.channel === Channel.HANDSHAKE)\n      return this._publish(0.01);\n\n    if (message.channel === Channel.CONNECT)\n      this._connectMessage = message;\n\n    return this._publish(this.MAX_DELAY);\n  },\n\n  _makePromise: function() {\n    var self = this;\n\n    this._requestPromise = this._requestPromise || new Promise(function(resolve) {\n      self._resolvePromise = resolve;\n    });\n  },\n\n  _publish: function(delay) {\n    this._makePromise();\n\n    this.addTimeout('publish', delay, function() {\n      this._flush();\n      delete this._requestPromise;\n    }, this);\n\n    return this._requestPromise;\n  },\n\n  _flush: function() {\n    this.removeTimeout('publish');\n\n    if (this._outbox.length > 1 && this._connectMessage)\n      this._connectMessage.advice = { timeout: 0 };\n\n    this._resolvePromise(this.request(this._outbox));\n\n    this._connectMessage = null;\n    this._outbox = [];\n  },\n\n  _flushLargeBatch: function() {\n    var string = this.encode(this._outbox);\n    if (string.length < this._dispatcher.maxRequestSize) return;\n    var last = this._outbox.pop();\n\n    this._makePromise();\n    this._flush();\n\n    if (last) this._outbox.push(last);\n  },\n\n  _receive: function(replies) {\n    if (!replies) return;\n    replies = [].concat(replies);\n\n    this.debug('Client ? received from ? via ?: ?',\n               this._dispatcher.clientId, this.endpoint.href, this.connectionType, replies);\n\n    for (var i = 0, n = replies.length; i < n; i++)\n      this._dispatcher.handleResponse(replies[i]);\n  },\n\n  _handleError: function(messages, immediate) {\n    messages = [].concat(messages);\n\n    this.debug('Client ? failed to send to ? via ?: ?',\n               this._dispatcher.clientId, this.endpoint.href, this.connectionType, messages);\n\n    for (var i = 0, n = messages.length; i < n; i++)\n      this._dispatcher.handleError(messages[i]);\n  },\n\n  _getCookies: function() {\n    var cookies = this._dispatcher.cookies,\n        url     = this.endpoint.href;\n\n    if (!cookies) return '';\n\n    return array.map(cookies.getCookiesSync(url), function(cookie) {\n      return cookie.cookieString();\n    }).join('; ');\n  },\n\n  _storeCookies: function(setCookie) {\n    var cookies = this._dispatcher.cookies,\n        url     = this.endpoint.href,\n        cookie;\n\n    if (!setCookie || !cookies) return;\n    setCookie = [].concat(setCookie);\n\n    for (var i = 0, n = setCookie.length; i < n; i++) {\n      cookie = Cookie.parse(setCookie[i]);\n      cookies.setCookieSync(cookie, url);\n    }\n  },\n\n  _findProxy: function() {\n    if (typeof process === 'undefined') return undefined;\n\n    var protocol = this.endpoint.protocol;\n    if (!protocol) return undefined;\n\n    var name   = protocol.replace(/:$/, '').toLowerCase() + '_proxy',\n        upcase = name.toUpperCase(),\n        env    = process.env,\n        keys, proxy;\n\n    if (name === 'http_proxy' && env.REQUEST_METHOD) {\n      keys = Object.keys(env).filter(function(k) { return /^http_proxy$/i.test(k) });\n      if (keys.length === 1) {\n        if (keys[0] === name && env[upcase] === undefined)\n          proxy = env[name];\n      } else if (keys.length > 1) {\n        proxy = env[name];\n      }\n      proxy = proxy || env['CGI_' + upcase];\n    } else {\n      proxy = env[name] || env[upcase];\n      if (proxy && !env[name])\n        console.warn('The environment variable ' + upcase +\n                     ' is discouraged. Use ' + name + '.');\n    }\n    return proxy;\n  }\n\n}), {\n  get: function(dispatcher, allowed, disabled, callback, context) {\n    var endpoint = dispatcher.endpoint;\n\n    array.asyncEach(this._transports, function(pair, resume) {\n      var connType     = pair[0], klass = pair[1],\n          connEndpoint = dispatcher.endpointFor(connType);\n\n      if (array.indexOf(disabled, connType) >= 0)\n        return resume();\n\n      if (array.indexOf(allowed, connType) < 0) {\n        klass.isUsable(dispatcher, connEndpoint, function() {});\n        return resume();\n      }\n\n      klass.isUsable(dispatcher, connEndpoint, function(isUsable) {\n        if (!isUsable) return resume();\n        var transport = klass.hasOwnProperty('create') ? klass.create(dispatcher, connEndpoint) : new klass(dispatcher, connEndpoint);\n        callback.call(context, transport);\n      });\n    }, function() {\n      throw new Error('Could not find a usable connection type for ' + endpoint.href);\n    });\n  },\n\n  register: function(type, klass) {\n    this._transports.push([type, klass]);\n    klass.prototype.connectionType = type;\n  },\n\n  getConnectionTypes: function() {\n    return array.map(this._transports, function(t) { return t[0] });\n  },\n\n  disable: function(feature) {\n    if (feature !== 'autodisconnect') return;\n\n    for (var i = 0; i < this._transports.length; i++)\n      this._transports[i][1]._unloaded = false;\n  },\n\n  _transports: []\n});\n\nassign(Transport.prototype, Logging);\nassign(Transport.prototype, Timeouts);\n\nmodule.exports = Transport;\n"]},"metadata":{},"sourceType":"script"}