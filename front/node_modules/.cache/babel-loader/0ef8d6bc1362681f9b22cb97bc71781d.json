{"ast":null,"code":"'use strict';\n\nvar asap = require('asap'),\n    Class = require('../util/class'),\n    Promise = require('../util/promise'),\n    array = require('../util/array'),\n    browser = require('../util/browser'),\n    constants = require('../util/constants'),\n    assign = require('../util/assign'),\n    validateOptions = require('../util/validate_options'),\n    Deferrable = require('../mixins/deferrable'),\n    Logging = require('../mixins/logging'),\n    Publisher = require('../mixins/publisher'),\n    Channel = require('./channel'),\n    Dispatcher = require('./dispatcher'),\n    Error = require('./error'),\n    Extensible = require('./extensible'),\n    Publication = require('./publication'),\n    Subscription = require('./subscription');\n\nvar Client = Class({\n  className: 'Client',\n  UNCONNECTED: 1,\n  CONNECTING: 2,\n  CONNECTED: 3,\n  DISCONNECTED: 4,\n  HANDSHAKE: 'handshake',\n  RETRY: 'retry',\n  NONE: 'none',\n  CONNECTION_TIMEOUT: 60,\n  DEFAULT_ENDPOINT: '/bayeux',\n  INTERVAL: 0,\n  initialize: function (endpoint, options) {\n    this.info('New client created for ?', endpoint);\n    options = options || {};\n    validateOptions(options, ['interval', 'timeout', 'endpoints', 'proxy', 'retry', 'scheduler', 'websocketExtensions', 'tls', 'ca']);\n    this._channels = new Channel.Set();\n    this._dispatcher = Dispatcher.create(this, endpoint || this.DEFAULT_ENDPOINT, options);\n    this._messageId = 0;\n    this._state = this.UNCONNECTED;\n    this._responseCallbacks = {};\n    this._advice = {\n      reconnect: this.RETRY,\n      interval: 1000 * (options.interval || this.INTERVAL),\n      timeout: 1000 * (options.timeout || this.CONNECTION_TIMEOUT)\n    };\n    this._dispatcher.timeout = this._advice.timeout / 1000;\n\n    this._dispatcher.bind('message', this._receiveMessage, this);\n\n    if (browser.Event && global.onbeforeunload !== undefined) browser.Event.on(global, 'beforeunload', function () {\n      if (array.indexOf(this._dispatcher._disabled, 'autodisconnect') < 0) this.disconnect();\n    }, this);\n  },\n  addWebsocketExtension: function (extension) {\n    return this._dispatcher.addWebsocketExtension(extension);\n  },\n  disable: function (feature) {\n    return this._dispatcher.disable(feature);\n  },\n  setHeader: function (name, value) {\n    return this._dispatcher.setHeader(name, value);\n  },\n  // Request\n  // MUST include:  * channel\n  //                * version\n  //                * supportedConnectionTypes\n  // MAY include:   * minimumVersion\n  //                * ext\n  //                * id\n  //\n  // Success Response                             Failed Response\n  // MUST include:  * channel                     MUST include:  * channel\n  //                * version                                    * successful\n  //                * supportedConnectionTypes                   * error\n  //                * clientId                    MAY include:   * supportedConnectionTypes\n  //                * successful                                 * advice\n  // MAY include:   * minimumVersion                             * version\n  //                * advice                                     * minimumVersion\n  //                * ext                                        * ext\n  //                * id                                         * id\n  //                * authSuccessful\n  handshake: function (callback, context) {\n    if (this._advice.reconnect === this.NONE) return;\n    if (this._state !== this.UNCONNECTED) return;\n    this._state = this.CONNECTING;\n    var self = this;\n    this.info('Initiating handshake with ?', this._dispatcher.endpoint.href);\n\n    this._dispatcher.selectTransport(constants.MANDATORY_CONNECTION_TYPES);\n\n    this._sendMessage({\n      channel: Channel.HANDSHAKE,\n      version: constants.BAYEUX_VERSION,\n      supportedConnectionTypes: this._dispatcher.getConnectionTypes()\n    }, {}, function (response) {\n      if (response.successful) {\n        this._state = this.CONNECTED;\n        this._dispatcher.clientId = response.clientId;\n\n        this._dispatcher.selectTransport(response.supportedConnectionTypes);\n\n        this.info('Handshake successful: ?', this._dispatcher.clientId);\n        this.subscribe(this._channels.getKeys(), true);\n        if (callback) asap(function () {\n          callback.call(context);\n        });\n      } else {\n        this.info('Handshake unsuccessful');\n        global.setTimeout(function () {\n          self.handshake(callback, context);\n        }, this._dispatcher.retry * 1000);\n        this._state = this.UNCONNECTED;\n      }\n    }, this);\n  },\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * clientId                           * successful\n  //                * connectionType                     * clientId\n  // MAY include:   * ext                 MAY include:   * error\n  //                * id                                 * advice\n  //                                                     * ext\n  //                                                     * id\n  //                                                     * timestamp\n  connect: function (callback, context) {\n    if (this._advice.reconnect === this.NONE) return;\n    if (this._state === this.DISCONNECTED) return;\n    if (this._state === this.UNCONNECTED) return this.handshake(function () {\n      this.connect(callback, context);\n    }, this);\n    this.callback(callback, context);\n    if (this._state !== this.CONNECTED) return;\n    this.info('Calling deferred actions for ?', this._dispatcher.clientId);\n    this.setDeferredStatus('succeeded');\n    this.setDeferredStatus('unknown');\n    if (this._connectRequest) return;\n    this._connectRequest = true;\n    this.info('Initiating connection for ?', this._dispatcher.clientId);\n\n    this._sendMessage({\n      channel: Channel.CONNECT,\n      clientId: this._dispatcher.clientId,\n      connectionType: this._dispatcher.connectionType\n    }, {}, this._cycleConnection, this);\n  },\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * clientId                           * successful\n  // MAY include:   * ext                                * clientId\n  //                * id                  MAY include:   * error\n  //                                                     * ext\n  //                                                     * id\n  disconnect: function () {\n    if (this._state !== this.CONNECTED) return;\n    this._state = this.DISCONNECTED;\n    this.info('Disconnecting ?', this._dispatcher.clientId);\n    var promise = new Publication();\n\n    this._sendMessage({\n      channel: Channel.DISCONNECT,\n      clientId: this._dispatcher.clientId\n    }, {}, function (response) {\n      if (response.successful) {\n        this._dispatcher.close();\n\n        promise.setDeferredStatus('succeeded');\n      } else {\n        promise.setDeferredStatus('failed', Error.parse(response.error));\n      }\n    }, this);\n\n    this.info('Clearing channel listeners for ?', this._dispatcher.clientId);\n    this._channels = new Channel.Set();\n    return promise;\n  },\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * clientId                           * successful\n  //                * subscription                       * clientId\n  // MAY include:   * ext                                * subscription\n  //                * id                  MAY include:   * error\n  //                                                     * advice\n  //                                                     * ext\n  //                                                     * id\n  //                                                     * timestamp\n  subscribe: function (channel, callback, context) {\n    if (channel instanceof Array) return array.map(channel, function (c) {\n      return this.subscribe(c, callback, context);\n    }, this);\n\n    var subscription = new Subscription(this, channel, callback, context),\n        force = callback === true,\n        hasSubscribe = this._channels.hasSubscription(channel);\n\n    if (hasSubscribe && !force) {\n      this._channels.subscribe([channel], subscription);\n\n      subscription.setDeferredStatus('succeeded');\n      return subscription;\n    }\n\n    this.connect(function () {\n      this.info('Client ? attempting to subscribe to ?', this._dispatcher.clientId, channel);\n      if (!force) this._channels.subscribe([channel], subscription);\n\n      this._sendMessage({\n        channel: Channel.SUBSCRIBE,\n        clientId: this._dispatcher.clientId,\n        subscription: channel\n      }, {}, function (response) {\n        if (!response.successful) {\n          subscription.setDeferredStatus('failed', Error.parse(response.error));\n          return this._channels.unsubscribe(channel, subscription);\n        }\n\n        var channels = [].concat(response.subscription);\n        this.info('Subscription acknowledged for ? to ?', this._dispatcher.clientId, channels);\n        subscription.setDeferredStatus('succeeded');\n      }, this);\n    }, this);\n    return subscription;\n  },\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * clientId                           * successful\n  //                * subscription                       * clientId\n  // MAY include:   * ext                                * subscription\n  //                * id                  MAY include:   * error\n  //                                                     * advice\n  //                                                     * ext\n  //                                                     * id\n  //                                                     * timestamp\n  unsubscribe: function (channel, subscription) {\n    if (channel instanceof Array) return array.map(channel, function (c) {\n      return this.unsubscribe(c, subscription);\n    }, this);\n\n    var dead = this._channels.unsubscribe(channel, subscription);\n\n    if (!dead) return;\n    this.connect(function () {\n      this.info('Client ? attempting to unsubscribe from ?', this._dispatcher.clientId, channel);\n\n      this._sendMessage({\n        channel: Channel.UNSUBSCRIBE,\n        clientId: this._dispatcher.clientId,\n        subscription: channel\n      }, {}, function (response) {\n        if (!response.successful) return;\n        var channels = [].concat(response.subscription);\n        this.info('Unsubscription acknowledged for ? from ?', this._dispatcher.clientId, channels);\n      }, this);\n    }, this);\n  },\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * data                               * successful\n  // MAY include:   * clientId            MAY include:   * id\n  //                * id                                 * error\n  //                * ext                                * ext\n  publish: function (channel, data, options) {\n    validateOptions(options || {}, ['attempts', 'deadline']);\n    var publication = new Publication();\n    this.connect(function () {\n      this.info('Client ? queueing published message to ?: ?', this._dispatcher.clientId, channel, data);\n\n      this._sendMessage({\n        channel: channel,\n        data: data,\n        clientId: this._dispatcher.clientId\n      }, options, function (response) {\n        if (response.successful) publication.setDeferredStatus('succeeded');else publication.setDeferredStatus('failed', Error.parse(response.error));\n      }, this);\n    }, this);\n    return publication;\n  },\n  _sendMessage: function (message, options, callback, context) {\n    message.id = this._generateMessageId();\n    var timeout = this._advice.timeout ? 1.2 * this._advice.timeout / 1000 : 1.2 * this._dispatcher.retry;\n    this.pipeThroughExtensions('outgoing', message, null, function (message) {\n      if (!message) return;\n      if (callback) this._responseCallbacks[message.id] = [callback, context];\n\n      this._dispatcher.sendMessage(message, timeout, options || {});\n    }, this);\n  },\n  _generateMessageId: function () {\n    this._messageId += 1;\n    if (this._messageId >= Math.pow(2, 32)) this._messageId = 0;\n    return this._messageId.toString(36);\n  },\n  _receiveMessage: function (message) {\n    var id = message.id,\n        callback;\n\n    if (message.successful !== undefined) {\n      callback = this._responseCallbacks[id];\n      delete this._responseCallbacks[id];\n    }\n\n    this.pipeThroughExtensions('incoming', message, null, function (message) {\n      if (!message) return;\n      if (message.advice) this._handleAdvice(message.advice);\n\n      this._deliverMessage(message);\n\n      if (callback) callback[0].call(callback[1], message);\n    }, this);\n  },\n  _handleAdvice: function (advice) {\n    assign(this._advice, advice);\n    this._dispatcher.timeout = this._advice.timeout / 1000;\n\n    if (this._advice.reconnect === this.HANDSHAKE && this._state !== this.DISCONNECTED) {\n      this._state = this.UNCONNECTED;\n      this._dispatcher.clientId = null;\n\n      this._cycleConnection();\n    }\n  },\n  _deliverMessage: function (message) {\n    if (!message.channel || message.data === undefined) return;\n    this.info('Client ? calling listeners for ? with ?', this._dispatcher.clientId, message.channel, message.data);\n\n    this._channels.distributeMessage(message);\n  },\n  _cycleConnection: function () {\n    if (this._connectRequest) {\n      this._connectRequest = null;\n      this.info('Closed connection for ?', this._dispatcher.clientId);\n    }\n\n    var self = this;\n    global.setTimeout(function () {\n      self.connect();\n    }, this._advice.interval);\n  }\n});\nassign(Client.prototype, Deferrable);\nassign(Client.prototype, Publisher);\nassign(Client.prototype, Logging);\nassign(Client.prototype, Extensible);\nmodule.exports = Client;","map":{"version":3,"sources":["/home/scocarojas/Documents/prototype/front/node_modules/faye/src/protocol/client.js"],"names":["asap","require","Class","Promise","array","browser","constants","assign","validateOptions","Deferrable","Logging","Publisher","Channel","Dispatcher","Error","Extensible","Publication","Subscription","Client","className","UNCONNECTED","CONNECTING","CONNECTED","DISCONNECTED","HANDSHAKE","RETRY","NONE","CONNECTION_TIMEOUT","DEFAULT_ENDPOINT","INTERVAL","initialize","endpoint","options","info","_channels","Set","_dispatcher","create","_messageId","_state","_responseCallbacks","_advice","reconnect","interval","timeout","bind","_receiveMessage","Event","global","onbeforeunload","undefined","on","indexOf","_disabled","disconnect","addWebsocketExtension","extension","disable","feature","setHeader","name","value","handshake","callback","context","self","href","selectTransport","MANDATORY_CONNECTION_TYPES","_sendMessage","channel","version","BAYEUX_VERSION","supportedConnectionTypes","getConnectionTypes","response","successful","clientId","subscribe","getKeys","call","setTimeout","retry","connect","setDeferredStatus","_connectRequest","CONNECT","connectionType","_cycleConnection","promise","DISCONNECT","close","parse","error","Array","map","c","subscription","force","hasSubscribe","hasSubscription","SUBSCRIBE","unsubscribe","channels","concat","dead","UNSUBSCRIBE","publish","data","publication","message","id","_generateMessageId","pipeThroughExtensions","sendMessage","Math","pow","toString","advice","_handleAdvice","_deliverMessage","distributeMessage","prototype","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar asap            = require('asap'),\n    Class           = require('../util/class'),\n    Promise         = require('../util/promise'),\n    array           = require('../util/array'),\n    browser         = require('../util/browser'),\n    constants       = require('../util/constants'),\n    assign          = require('../util/assign'),\n    validateOptions = require('../util/validate_options'),\n    Deferrable      = require('../mixins/deferrable'),\n    Logging         = require('../mixins/logging'),\n    Publisher       = require('../mixins/publisher'),\n    Channel         = require('./channel'),\n    Dispatcher      = require('./dispatcher'),\n    Error           = require('./error'),\n    Extensible      = require('./extensible'),\n    Publication     = require('./publication'),\n    Subscription    = require('./subscription');\n\nvar Client = Class({ className: 'Client',\n  UNCONNECTED:  1,\n  CONNECTING:   2,\n  CONNECTED:    3,\n  DISCONNECTED: 4,\n\n  HANDSHAKE: 'handshake',\n  RETRY:     'retry',\n  NONE:      'none',\n\n  CONNECTION_TIMEOUT: 60,\n\n  DEFAULT_ENDPOINT: '/bayeux',\n  INTERVAL:         0,\n\n  initialize: function(endpoint, options) {\n    this.info('New client created for ?', endpoint);\n    options = options || {};\n\n    validateOptions(options, ['interval', 'timeout', 'endpoints', 'proxy', 'retry', 'scheduler', 'websocketExtensions', 'tls', 'ca']);\n\n    this._channels   = new Channel.Set();\n    this._dispatcher = Dispatcher.create(this, endpoint || this.DEFAULT_ENDPOINT, options);\n\n    this._messageId = 0;\n    this._state     = this.UNCONNECTED;\n\n    this._responseCallbacks = {};\n\n    this._advice = {\n      reconnect: this.RETRY,\n      interval:  1000 * (options.interval || this.INTERVAL),\n      timeout:   1000 * (options.timeout  || this.CONNECTION_TIMEOUT)\n    };\n    this._dispatcher.timeout = this._advice.timeout / 1000;\n\n    this._dispatcher.bind('message', this._receiveMessage, this);\n\n    if (browser.Event && global.onbeforeunload !== undefined)\n      browser.Event.on(global, 'beforeunload', function() {\n        if (array.indexOf(this._dispatcher._disabled, 'autodisconnect') < 0)\n          this.disconnect();\n      }, this);\n  },\n\n  addWebsocketExtension: function(extension) {\n    return this._dispatcher.addWebsocketExtension(extension);\n  },\n\n  disable: function(feature) {\n    return this._dispatcher.disable(feature);\n  },\n\n  setHeader: function(name, value) {\n    return this._dispatcher.setHeader(name, value);\n  },\n\n  // Request\n  // MUST include:  * channel\n  //                * version\n  //                * supportedConnectionTypes\n  // MAY include:   * minimumVersion\n  //                * ext\n  //                * id\n  //\n  // Success Response                             Failed Response\n  // MUST include:  * channel                     MUST include:  * channel\n  //                * version                                    * successful\n  //                * supportedConnectionTypes                   * error\n  //                * clientId                    MAY include:   * supportedConnectionTypes\n  //                * successful                                 * advice\n  // MAY include:   * minimumVersion                             * version\n  //                * advice                                     * minimumVersion\n  //                * ext                                        * ext\n  //                * id                                         * id\n  //                * authSuccessful\n  handshake: function(callback, context) {\n    if (this._advice.reconnect === this.NONE) return;\n    if (this._state !== this.UNCONNECTED) return;\n\n    this._state = this.CONNECTING;\n    var self = this;\n\n    this.info('Initiating handshake with ?', this._dispatcher.endpoint.href);\n    this._dispatcher.selectTransport(constants.MANDATORY_CONNECTION_TYPES);\n\n    this._sendMessage({\n      channel:                  Channel.HANDSHAKE,\n      version:                  constants.BAYEUX_VERSION,\n      supportedConnectionTypes: this._dispatcher.getConnectionTypes()\n\n    }, {}, function(response) {\n\n      if (response.successful) {\n        this._state = this.CONNECTED;\n        this._dispatcher.clientId  = response.clientId;\n\n        this._dispatcher.selectTransport(response.supportedConnectionTypes);\n\n        this.info('Handshake successful: ?', this._dispatcher.clientId);\n\n        this.subscribe(this._channels.getKeys(), true);\n        if (callback) asap(function() { callback.call(context) });\n\n      } else {\n        this.info('Handshake unsuccessful');\n        global.setTimeout(function() { self.handshake(callback, context) }, this._dispatcher.retry * 1000);\n        this._state = this.UNCONNECTED;\n      }\n    }, this);\n  },\n\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * clientId                           * successful\n  //                * connectionType                     * clientId\n  // MAY include:   * ext                 MAY include:   * error\n  //                * id                                 * advice\n  //                                                     * ext\n  //                                                     * id\n  //                                                     * timestamp\n  connect: function(callback, context) {\n    if (this._advice.reconnect === this.NONE) return;\n    if (this._state === this.DISCONNECTED) return;\n\n    if (this._state === this.UNCONNECTED)\n      return this.handshake(function() { this.connect(callback, context) }, this);\n\n    this.callback(callback, context);\n    if (this._state !== this.CONNECTED) return;\n\n    this.info('Calling deferred actions for ?', this._dispatcher.clientId);\n    this.setDeferredStatus('succeeded');\n    this.setDeferredStatus('unknown');\n\n    if (this._connectRequest) return;\n    this._connectRequest = true;\n\n    this.info('Initiating connection for ?', this._dispatcher.clientId);\n\n    this._sendMessage({\n      channel:        Channel.CONNECT,\n      clientId:       this._dispatcher.clientId,\n      connectionType: this._dispatcher.connectionType\n\n    }, {}, this._cycleConnection, this);\n  },\n\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * clientId                           * successful\n  // MAY include:   * ext                                * clientId\n  //                * id                  MAY include:   * error\n  //                                                     * ext\n  //                                                     * id\n  disconnect: function() {\n    if (this._state !== this.CONNECTED) return;\n    this._state = this.DISCONNECTED;\n\n    this.info('Disconnecting ?', this._dispatcher.clientId);\n    var promise = new Publication();\n\n    this._sendMessage({\n      channel:  Channel.DISCONNECT,\n      clientId: this._dispatcher.clientId\n\n    }, {}, function(response) {\n      if (response.successful) {\n        this._dispatcher.close();\n        promise.setDeferredStatus('succeeded');\n      } else {\n        promise.setDeferredStatus('failed', Error.parse(response.error));\n      }\n    }, this);\n\n    this.info('Clearing channel listeners for ?', this._dispatcher.clientId);\n    this._channels = new Channel.Set();\n\n    return promise;\n  },\n\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * clientId                           * successful\n  //                * subscription                       * clientId\n  // MAY include:   * ext                                * subscription\n  //                * id                  MAY include:   * error\n  //                                                     * advice\n  //                                                     * ext\n  //                                                     * id\n  //                                                     * timestamp\n  subscribe: function(channel, callback, context) {\n    if (channel instanceof Array)\n      return array.map(channel, function(c) {\n        return this.subscribe(c, callback, context);\n      }, this);\n\n    var subscription = new Subscription(this, channel, callback, context),\n        force        = (callback === true),\n        hasSubscribe = this._channels.hasSubscription(channel);\n\n    if (hasSubscribe && !force) {\n      this._channels.subscribe([channel], subscription);\n      subscription.setDeferredStatus('succeeded');\n      return subscription;\n    }\n\n    this.connect(function() {\n      this.info('Client ? attempting to subscribe to ?', this._dispatcher.clientId, channel);\n      if (!force) this._channels.subscribe([channel], subscription);\n\n      this._sendMessage({\n        channel:      Channel.SUBSCRIBE,\n        clientId:     this._dispatcher.clientId,\n        subscription: channel\n\n      }, {}, function(response) {\n        if (!response.successful) {\n          subscription.setDeferredStatus('failed', Error.parse(response.error));\n          return this._channels.unsubscribe(channel, subscription);\n        }\n\n        var channels = [].concat(response.subscription);\n        this.info('Subscription acknowledged for ? to ?', this._dispatcher.clientId, channels);\n        subscription.setDeferredStatus('succeeded');\n      }, this);\n    }, this);\n\n    return subscription;\n  },\n\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * clientId                           * successful\n  //                * subscription                       * clientId\n  // MAY include:   * ext                                * subscription\n  //                * id                  MAY include:   * error\n  //                                                     * advice\n  //                                                     * ext\n  //                                                     * id\n  //                                                     * timestamp\n  unsubscribe: function(channel, subscription) {\n    if (channel instanceof Array)\n      return array.map(channel, function(c) {\n        return this.unsubscribe(c, subscription);\n      }, this);\n\n    var dead = this._channels.unsubscribe(channel, subscription);\n    if (!dead) return;\n\n    this.connect(function() {\n      this.info('Client ? attempting to unsubscribe from ?', this._dispatcher.clientId, channel);\n\n      this._sendMessage({\n        channel:      Channel.UNSUBSCRIBE,\n        clientId:     this._dispatcher.clientId,\n        subscription: channel\n\n      }, {}, function(response) {\n        if (!response.successful) return;\n\n        var channels = [].concat(response.subscription);\n        this.info('Unsubscription acknowledged for ? from ?', this._dispatcher.clientId, channels);\n      }, this);\n    }, this);\n  },\n\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * data                               * successful\n  // MAY include:   * clientId            MAY include:   * id\n  //                * id                                 * error\n  //                * ext                                * ext\n  publish: function(channel, data, options) {\n    validateOptions(options || {}, ['attempts', 'deadline']);\n    var publication = new Publication();\n\n    this.connect(function() {\n      this.info('Client ? queueing published message to ?: ?', this._dispatcher.clientId, channel, data);\n\n      this._sendMessage({\n        channel:  channel,\n        data:     data,\n        clientId: this._dispatcher.clientId\n\n      }, options, function(response) {\n        if (response.successful)\n          publication.setDeferredStatus('succeeded');\n        else\n          publication.setDeferredStatus('failed', Error.parse(response.error));\n      }, this);\n    }, this);\n\n    return publication;\n  },\n\n  _sendMessage: function(message, options, callback, context) {\n    message.id = this._generateMessageId();\n\n    var timeout = this._advice.timeout\n                ? 1.2 * this._advice.timeout / 1000\n                : 1.2 * this._dispatcher.retry;\n\n    this.pipeThroughExtensions('outgoing', message, null, function(message) {\n      if (!message) return;\n      if (callback) this._responseCallbacks[message.id] = [callback, context];\n      this._dispatcher.sendMessage(message, timeout, options || {});\n    }, this);\n  },\n\n  _generateMessageId: function() {\n    this._messageId += 1;\n    if (this._messageId >= Math.pow(2,32)) this._messageId = 0;\n    return this._messageId.toString(36);\n  },\n\n  _receiveMessage: function(message) {\n    var id = message.id, callback;\n\n    if (message.successful !== undefined) {\n      callback = this._responseCallbacks[id];\n      delete this._responseCallbacks[id];\n    }\n\n    this.pipeThroughExtensions('incoming', message, null, function(message) {\n      if (!message) return;\n      if (message.advice) this._handleAdvice(message.advice);\n      this._deliverMessage(message);\n      if (callback) callback[0].call(callback[1], message);\n    }, this);\n  },\n\n  _handleAdvice: function(advice) {\n    assign(this._advice, advice);\n    this._dispatcher.timeout = this._advice.timeout / 1000;\n\n    if (this._advice.reconnect === this.HANDSHAKE && this._state !== this.DISCONNECTED) {\n      this._state = this.UNCONNECTED;\n      this._dispatcher.clientId = null;\n      this._cycleConnection();\n    }\n  },\n\n  _deliverMessage: function(message) {\n    if (!message.channel || message.data === undefined) return;\n    this.info('Client ? calling listeners for ? with ?', this._dispatcher.clientId, message.channel, message.data);\n    this._channels.distributeMessage(message);\n  },\n\n  _cycleConnection: function() {\n    if (this._connectRequest) {\n      this._connectRequest = null;\n      this.info('Closed connection for ?', this._dispatcher.clientId);\n    }\n    var self = this;\n    global.setTimeout(function() { self.connect() }, this._advice.interval);\n  }\n});\n\nassign(Client.prototype, Deferrable);\nassign(Client.prototype, Publisher);\nassign(Client.prototype, Logging);\nassign(Client.prototype, Extensible);\n\nmodule.exports = Client;\n"]},"metadata":{},"sourceType":"script"}